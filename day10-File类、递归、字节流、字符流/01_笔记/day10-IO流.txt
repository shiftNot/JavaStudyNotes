内容回顾：
1.线程状态
	正常情况：新建、可运行、被终止
	加锁：锁阻塞
	加锁无限等待：无限等待（锁对象.wait()）
	加锁计时等待：计时等待（锁对象.wait(long time)）
	不加锁计时等待：计时等待(Thread.sleep(long time))

2.线程等待唤醒机制
	实现分析：
		1.无论是否使用等待唤醒，线程都是抢占式的
		2.线程等待唤醒 需要使用锁对象调用wait和notify或notifyAll方法
		3.在调用wait和notify方法时要使用同一个锁对象
		注意：线程的等待唤醒要写在synchronized代码块中  使用锁对象调用方法

3.lambda表达式
	概念：JDK8提供的一个新特性 简化代码操作 替代使用匿名内部类创建接口对象
	使用场景：
		作为变量
		作为方法实参
		作为方法返回值
	使用前提：
		一个接口中只有一个抽象方法 这样的接口我们称为函数式接口  才能使用lambda表达式
	使用套路：
		1.判断当前接口是不是函数式接口
		2.使用格式：()->{}
		3.在小括号中写接口抽象方法的参数  
			【1.参数类型可以省略 2.如果只有一个参数 则小括号可以省略 3.参数名可以随便起】
		4.在大括号中写接口抽象方法的实现代码
			【1.如果实现代码只有一句  可以省略大括号、代码后的;、省略return关键字】
		
4.Stream流
	概念：JDK8提供的一个新特性 简化集合操作代码  主要使用函数式编程思想完成
	获取流：
		1.集合：.stream()
		2.数组：Stream.of(数组);
	特点：
		1.流是一次性的  不能重复使用 
		2.流的操作 一定要有终结方法  如果没有则延迟方法不会执行
	常用功能：
		终结方法：返回值不是Stream流对象类型的方法  不可以继续进行流式操作
			long count：统计流中元素的个数
			void foreach：对流中每个元素进行操作
			Object[] toArray：将流中元素收集到数组中
			List|Set  collect(Collectors.toList|Collectors.toSet)：将流中元素收集到集合中
		
		延迟方法：返回值依然是Stream流对象类型的方法  可以继续进行流式操作
			filter：对流中元素进行过滤
			limit(n):选取流中前n个元素【包含n】
			skip(n):丢弃流中前n个元素【包含n】，选取剩余的元素
			map():对流中元素进行映射【转换】
			sorted()：对流中元素进行排序
			
绝对路径和相对路径
	绝对路径：从盘符开始的路径，是一个完整的路径
		eg:D:\\workspace\\java126\\day10\\aa\\a.txt		
		使用绝对路径可能出现的问题：
			1.