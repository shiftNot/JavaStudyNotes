继承
	1.向上抽取 
		找到所有的子类
		抽取所有的子类公共的属性和行为
		根据公共的属性和行为，以及is-a的关系，找出一个父类(找名字)
	2.向下实现
		定义父类
		定义子类，继承父类(父类中有的东西，子类不用再写了)
			继承格式:public class 子类名 extends 父类名{}
	3.访问规则
		3.1子类不能继承的内容
				子类不能继承父类构造方法
				从内存的角度来说，子类可以继承父类的私有内容，但是不可以直接使用。需要通过父类中的非私有方法间接访问。
		3.2 子父类成员变量同名，子类对象优先使用自己的。
		3.3 子父类成员方法同名，子类对象优先使用自己的。
		3.4  方法重写:按照概念理解，记得要加Override注解。使用方式 @Override
		3.5  构造方法: 默认，首行，手动替代默认。
	4.this和super的使用
		this代表本类中的内容
			成员变量、
			成员方法、构造方法 (一般不用)
		super代表父类中的内容		
			成员变量、成员方法、构造方法(三个都很常用)
	5.内存图	
	6.继承的特点
		单继承，多层继承，父类有多个子类。
抽象类
	存在的原因:
		当父类中的方法，子类实现各不相同的时候，父类中该方法就应该定义成抽象方法，父类就应该是抽象类。
	格式
		抽象类	public abstract class 类名{}
		抽象方法
				public abstarct 返回值类型 方法名(形参);
	注意:
		父类如果是抽象类，且子类不是抽象类，子类必须重写父类的抽象方法。
		
	模板模式案例
		子类实现相同的，父类中定义为非抽象的，子类实现不相同的，父类定义为抽象的,将来交给自己自己实现。
final
	修饰类	类不能被继承
	修饰方法	方法不能被重写
	修饰变量
		被final修饰的变量，称为自定义常量。    
		常量分为自定义常量和字面值常量。
		一旦赋值，不能改变。
		修饰局部变量。一旦赋值不能改变。
		修饰成员变量，不识别默认值，必须手动赋值。
		可以直接赋值，也可以在构造方法中赋值，但是要保证所有的构造方法执行后，都有赋值操作。
	
	
	
	
	
	
	
	