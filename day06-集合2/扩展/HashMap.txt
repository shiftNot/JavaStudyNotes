概念
	数组优势/劣势
	链表优势/劣势
	优势结合:散列表
	散列表特点
		哈希值尽可能不一样。
	什么是哈希？
		hashCode方法的值
	HashMap集合继承体系

原理
	HashMap的工作原理 ：HashMap是基于散列法（又称哈希法）的原理，
	使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。
	当我们给put()方法传递键和值时，我们先对键调用hashCode()方法获取(哈希)值，
	返回的hashCode值用于找到bucket（桶）位置来储存Entry对象。
	HashMap是在bucket中储存键对象和值对象，作为Map.Entry。并不是仅仅只在bucket中存储值。
	
	存储结构:数组+链表+红黑树
	Node节点
	put原理介绍：hash值--扰动函数--路由寻址((table.length-1)&node.hash)
	什么是Hash碰撞：哈希值如果相同，就会存储到相同的列。
	什么是链化：哈希值相同，就会存储在同系列，产生桶状结构，桶结构过长，查询数据低效。
	jdk8为什么引入红黑树：避免过长的桶状结构
	HashMap扩容原理：数据过多，链化严重，默认以两倍的长度扩容。
		1.该列添加元素超过8个，且数组长度小于64，会进行扩容，超过64个只树化，不扩容。
		2.数组元素个数超过阈值的时候，会进行扩容(该操作位于判定该列元素个数之后)。


源码
	
	static final int DEFAULT_INITIAL_CAPACITY = 1 << 4;  	默认数组大小
	static final int MAXIMUM_CAPACITY = 1 << 30; 	数组最大长度
	static final float DEFAULT_LOAD_FACTOR = 0.75f; 	默认负载因子
	static final int TREEIFY_THRESHOLD = 8;	树化阈值
	static final int UNTREEIFY_THRESHOLD = 6; 	树降级阈值
	static final int MIN_TREEIFY_CAPACITY = 64;	树化阈值
	
	transient Node<K,V>[] table; 哈希表
	transient Set<Map.Entry<K,V>> entrySet; 键值对对象集合
	transient int size;元素长度
	transient int modCount; 增删元素次数
	int threshold;扩容阈值     扩容阈值=loadFactor*capacity
	final float loadFactor;    负载因子    

看源码
	put--putVal
	扩容resize
	tableSizeFor
	二进制(位运算)
	
